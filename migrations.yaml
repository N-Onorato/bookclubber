migrations:
  - version: 1
    name: "Initial schema - Complete book club system"
    description: "Create all tables for users, sessions, books, cycles, suggestions, votes, reading chunks, meetings, authors blocklist, themes, rankings, audit log, and events"
    reversible: true
    up: |
      -- ============================================================================
      -- CORE TABLES
      -- ============================================================================

      -- Users & Authentication
      CREATE TABLE users (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        name TEXT NOT NULL,
        role TEXT DEFAULT 'member' CHECK (role IN ('member', 'admin')),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE sessions (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        expires_at DATETIME NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Suggestion/Voting Cycles
      CREATE TABLE cycles (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL CHECK (type IN ('suggestion', 'voting')),
        theme TEXT,
        starts_at DATETIME NOT NULL,
        ends_at DATETIME NOT NULL,
        is_active BOOLEAN DEFAULT FALSE,
        winner_book_id TEXT REFERENCES books(id),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Books
      CREATE TABLE books (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        author TEXT NOT NULL,
        isbn TEXT,
        cover_url TEXT,
        description TEXT,
        page_count INTEGER,
        publication_date DATE,

        -- Metadata
        is_series BOOLEAN DEFAULT FALSE,
        series_name TEXT,
        series_position INTEGER,

        -- Tracking
        suggested_by_user_id TEXT REFERENCES users(id),
        suggestion_cycle_id TEXT REFERENCES cycles(id),

        -- Status
        status TEXT DEFAULT 'suggested' CHECK (status IN ('suggested', 'voting', 'reading', 'completed')),
        completed_at DATETIME,

        -- External source tracking
        source TEXT,
        source_id TEXT,

        -- System
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        deleted_at DATETIME
      );

      -- Book Suggestions
      CREATE TABLE suggestions (
        id TEXT PRIMARY KEY,
        cycle_id TEXT NOT NULL REFERENCES cycles(id) ON DELETE CASCADE,
        user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        book_id TEXT NOT NULL REFERENCES books(id) ON DELETE CASCADE,
        reason TEXT, -- Added in v3
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(cycle_id, user_id, book_id)
      );

      -- Votes
      CREATE TABLE votes (
        id TEXT PRIMARY KEY,
        cycle_id TEXT NOT NULL REFERENCES cycles(id) ON DELETE CASCADE,
        user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        book_id TEXT NOT NULL REFERENCES books(id) ON DELETE CASCADE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(cycle_id, user_id, book_id)
      );

      -- Reading Schedule
      CREATE TABLE reading_chunks (
        id TEXT PRIMARY KEY,
        book_id TEXT NOT NULL REFERENCES books(id) ON DELETE CASCADE,
        chunk_number INTEGER NOT NULL,
        start_chapter TEXT,
        end_chapter TEXT,
        start_page INTEGER,
        end_page INTEGER,
        due_date DATE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Meetings
      CREATE TABLE meetings (
        id TEXT PRIMARY KEY,
        reading_chunk_id TEXT REFERENCES reading_chunks(id) ON DELETE SET NULL,
        scheduled_at DATETIME NOT NULL,
        is_tentative BOOLEAN DEFAULT FALSE,
        is_skipped BOOLEAN DEFAULT FALSE,
        notes TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Author Blocklist
      CREATE TABLE blocked_authors (
        id TEXT PRIMARY KEY,
        author_name TEXT UNIQUE NOT NULL,
        reason TEXT,
        blocked_by_user_id TEXT REFERENCES users(id),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Themes for wheel
      CREATE TABLE themes (
        id TEXT PRIMARY KEY,
        theme_text TEXT UNIQUE NOT NULL,
        used_count INTEGER DEFAULT 0,
        last_used_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- Rankings
      CREATE TABLE rankings (
        id TEXT PRIMARY KEY,
        book_id TEXT NOT NULL REFERENCES books(id) ON DELETE CASCADE,
        user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        tier TEXT NOT NULL CHECK (tier IN ('S', 'A', 'B', 'C', 'D', 'F')),
        ranking_session_id TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(book_id, user_id, ranking_session_id)
      );

      -- ============================================================================
      -- SYSTEM TABLES
      -- ============================================================================

      CREATE TABLE audit_log (
        id TEXT PRIMARY KEY,
        user_id TEXT REFERENCES users(id),
        action TEXT NOT NULL,
        entity_type TEXT,
        entity_id TEXT,
        changes TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE events (
        id TEXT PRIMARY KEY,
        event_type TEXT NOT NULL,
        event_data TEXT,
        processed_at DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ============================================================================
      -- INDEXES
      -- ============================================================================

      CREATE INDEX idx_users_email ON users(email);
      CREATE INDEX idx_sessions_user_id ON sessions(user_id);
      CREATE INDEX idx_sessions_expires ON sessions(expires_at);

      CREATE INDEX idx_books_status ON books(status);
      CREATE INDEX idx_books_suggested_by ON books(suggested_by_user_id);
      CREATE INDEX idx_books_deleted ON books(deleted_at);
      CREATE INDEX idx_books_author ON books(author);
      CREATE INDEX idx_books_isbn ON books(isbn);
      CREATE INDEX idx_books_source ON books(source, source_id);

      CREATE INDEX idx_cycles_active ON cycles(is_active);
      CREATE INDEX idx_cycles_type ON cycles(type);

      CREATE INDEX idx_suggestions_cycle_user ON suggestions(cycle_id, user_id);
      CREATE INDEX idx_suggestions_book ON suggestions(book_id);

      CREATE INDEX idx_votes_cycle_user ON votes(cycle_id, user_id);
      CREATE INDEX idx_votes_cycle_book ON votes(cycle_id, book_id);

      CREATE INDEX idx_chunks_book ON reading_chunks(book_id);
      CREATE INDEX idx_chunks_due_date ON reading_chunks(due_date);

      CREATE INDEX idx_meetings_scheduled ON meetings(scheduled_at);
      CREATE INDEX idx_meetings_chunk ON meetings(reading_chunk_id);

      CREATE INDEX idx_rankings_book ON rankings(book_id);
      CREATE INDEX idx_rankings_user ON rankings(user_id);

      CREATE INDEX idx_events_unprocessed ON events(processed_at) WHERE processed_at IS NULL;
      CREATE INDEX idx_events_type ON events(event_type);

      CREATE INDEX idx_audit_user ON audit_log(user_id);
      CREATE INDEX idx_audit_entity ON audit_log(entity_type, entity_id);
      CREATE INDEX idx_audit_created ON audit_log(created_at);

      -- ============================================================================
      -- TRIGGERS
      -- ============================================================================

      CREATE TRIGGER update_users_updated_at
        AFTER UPDATE ON users
        FOR EACH ROW
      BEGIN
        UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;

      CREATE TRIGGER update_books_updated_at
        AFTER UPDATE ON books
        FOR EACH ROW
      BEGIN
        UPDATE books SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;

      CREATE TRIGGER update_meetings_updated_at
        AFTER UPDATE ON meetings
        FOR EACH ROW
      BEGIN
        UPDATE meetings SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;

      CREATE TRIGGER update_rankings_updated_at
        AFTER UPDATE ON rankings
        FOR EACH ROW
      BEGIN
        UPDATE rankings SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;

      CREATE TRIGGER update_suggestions_updated_at
        AFTER UPDATE ON suggestions
        FOR EACH ROW
      BEGIN
        UPDATE suggestions SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;
  - version: 2
    name: "Add max suggestions and votes per user to cycles"
    description: "Add max_suggestions_per_user and max_votes_per_user columns to cycles table"
    reversible: true
    up: |
      ALTER TABLE cycles ADD COLUMN max_suggestions_per_user INTEGER DEFAULT 3;
      ALTER TABLE cycles ADD COLUMN max_votes_per_user INTEGER DEFAULT 3;
    down: |
      -- SQLite doesn't support DROP COLUMN, so we need to recreate the table
      CREATE TABLE cycles_backup (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL CHECK (type IN ('suggestion', 'voting')),
        theme TEXT,
        starts_at DATETIME NOT NULL,
        ends_at DATETIME NOT NULL,
        is_active BOOLEAN DEFAULT FALSE,
        winner_book_id TEXT REFERENCES books(id),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      INSERT INTO cycles_backup SELECT id, type, theme, starts_at, ends_at, is_active, winner_book_id, created_at FROM cycles;

      DROP TABLE cycles;

      ALTER TABLE cycles_backup RENAME TO cycles;

      CREATE INDEX idx_cycles_active ON cycles(is_active);
      CREATE INDEX idx_cycles_type ON cycles(type);
  - version: 3
    name: "Add local image storage support"
    description: "Add columns for local cover image paths and original URLs to support provider-agnostic image storage"
    reversible: true
    up: |
      -- Add new columns for local image storage
      ALTER TABLE books ADD COLUMN local_cover_path TEXT;
      ALTER TABLE books ADD COLUMN original_cover_url TEXT;

      -- Migrate existing cover_url values to original_cover_url
      UPDATE books SET original_cover_url = cover_url WHERE cover_url IS NOT NULL;
    down: |
      -- SQLite doesn't support DROP COLUMN directly
      -- If we need to rollback, we would recreate the table without these columns
      -- For now, setting them to NULL is sufficient for a down migration
      UPDATE books SET local_cover_path = NULL, original_cover_url = NULL;
  - version: 4
    name: "Refactor cycles to cycles+phases architecture"
    description: "Rename current 'cycles' table to 'phases' and create new top-level 'cycles' table. This allows phases (suggestion, voting) to be linked under a single cycle."
    reversible: true
    up: |
      -- ============================================================================
      -- STEP 1: Rename cycles table to phases and update structure
      -- ============================================================================

      -- Rename the existing cycles table to phases
      ALTER TABLE cycles RENAME TO phases;

      -- Drop old indexes
      DROP INDEX IF EXISTS idx_cycles_active;
      DROP INDEX IF EXISTS idx_cycles_type;

      -- ============================================================================
      -- STEP 2: Create new cycles table (top-level entity)
      -- ============================================================================

      CREATE TABLE cycles (
        id TEXT PRIMARY KEY,
        name TEXT,
        theme TEXT,
        winner_book_id TEXT REFERENCES books(id),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- ============================================================================
      -- STEP 3: Add cycle_id to phases table
      -- ============================================================================

      -- Add cycle_id column to phases (will be populated in next step)
      ALTER TABLE phases ADD COLUMN cycle_id TEXT REFERENCES cycles(id) ON DELETE CASCADE;

      -- ============================================================================
      -- STEP 4: Migrate existing data
      -- ============================================================================

      -- For each existing phase, create a corresponding cycle
      -- Group suggestion+voting pairs by theme, or create individual cycles
      INSERT INTO cycles (id, name, theme, winner_book_id, created_at)
      SELECT
        LOWER(HEX(RANDOMBLOB(16))),
        COALESCE(theme, 'Cycle ' || SUBSTR(id, 1, 8)),
        theme,
        winner_book_id,
        MIN(created_at)
      FROM phases
      GROUP BY theme, winner_book_id;

      -- Update phases to link to their cycles
      -- If phases share a theme, link them to the same cycle
      UPDATE phases
      SET cycle_id = (
        SELECT c.id
        FROM cycles c
        WHERE c.theme = phases.theme
          OR (c.theme IS NULL AND phases.theme IS NULL)
        LIMIT 1
      );

      -- For any orphaned phases without a cycle, create a cycle
      INSERT INTO cycles (id, name, created_at)
      SELECT
        LOWER(HEX(RANDOMBLOB(16))),
        'Cycle for ' || type || ' phase',
        created_at
      FROM phases
      WHERE cycle_id IS NULL;

      -- Link orphaned phases
      UPDATE phases
      SET cycle_id = (
        SELECT c.id
        FROM cycles c
        WHERE c.created_at = phases.created_at
        LIMIT 1
      )
      WHERE cycle_id IS NULL;

      -- ============================================================================
      -- STEP 5: Update suggestions and votes tables
      -- ============================================================================

      -- Rename cycle_id to phase_id in suggestions
      ALTER TABLE suggestions RENAME COLUMN cycle_id TO phase_id;

      -- Rename cycle_id to phase_id in votes
      ALTER TABLE votes RENAME COLUMN cycle_id TO phase_id;

      -- ============================================================================
      -- STEP 6: Update books table reference
      -- ============================================================================

      -- The books.suggestion_cycle_id now refers to a phase, not a cycle
      -- We'll update it to suggestion_phase_id for clarity
      ALTER TABLE books RENAME COLUMN suggestion_cycle_id TO suggestion_phase_id;

      -- ============================================================================
      -- STEP 7: Move winner_book_id from phases to cycles
      -- ============================================================================

      -- Update cycles.winner_book_id from phases
      UPDATE cycles
      SET winner_book_id = (
        SELECT p.winner_book_id
        FROM phases p
        WHERE p.cycle_id = cycles.id
          AND p.winner_book_id IS NOT NULL
        LIMIT 1
      );

      -- Remove winner_book_id from phases (no longer needed at phase level)
      -- Note: SQLite doesn't support DROP COLUMN easily, so we'll leave it for now
      -- but document that it's deprecated and should use cycles.winner_book_id

      -- ============================================================================
      -- STEP 8: Create new indexes
      -- ============================================================================

      CREATE INDEX idx_phases_cycle ON phases(cycle_id);
      CREATE INDEX idx_phases_type ON phases(type);
      CREATE INDEX idx_phases_active ON phases(is_active);
      CREATE INDEX idx_phases_dates ON phases(starts_at, ends_at);

      CREATE INDEX idx_suggestions_phase_user ON suggestions(phase_id, user_id);
      CREATE INDEX idx_votes_phase_user ON votes(phase_id, user_id);
      CREATE INDEX idx_votes_phase_book ON votes(phase_id, book_id);

      -- ============================================================================
      -- STEP 9: Create trigger for cycles updated_at
      -- ============================================================================

      CREATE TRIGGER update_cycles_updated_at
        AFTER UPDATE ON cycles
        FOR EACH ROW
      BEGIN
        UPDATE cycles SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
      END;
    down: |
      -- ============================================================================
      -- ROLLBACK: Restore original cycles table structure
      -- ============================================================================

      -- Drop new indexes
      DROP INDEX IF EXISTS idx_phases_cycle;
      DROP INDEX IF EXISTS idx_phases_type;
      DROP INDEX IF EXISTS idx_phases_active;
      DROP INDEX IF EXISTS idx_phases_dates;

      -- Rename phase_id back to cycle_id in suggestions and votes
      ALTER TABLE suggestions RENAME COLUMN phase_id TO cycle_id;
      ALTER TABLE votes RENAME COLUMN phase_id TO cycle_id;

      -- Rename suggestion_phase_id back to suggestion_cycle_id in books
      ALTER TABLE books RENAME COLUMN suggestion_phase_id TO suggestion_cycle_id;

      -- Drop cycle_id column from phases
      -- SQLite limitation: can't drop column, so we recreate the table
      CREATE TABLE phases_backup AS
      SELECT id, type, theme, starts_at, ends_at, is_active, winner_book_id,
             max_suggestions_per_user, max_votes_per_user, created_at
      FROM phases;

      DROP TABLE phases;
      ALTER TABLE phases_backup RENAME TO cycles;

      -- Drop the cycles table
      DROP TABLE cycles;
      DROP TRIGGER IF EXISTS update_cycles_updated_at;

      -- Recreate original indexes
      CREATE INDEX idx_cycles_active ON cycles(is_active);
      CREATE INDEX idx_cycles_type ON cycles(type);
      CREATE INDEX idx_suggestions_cycle_user ON suggestions(cycle_id, user_id);
      CREATE INDEX idx_votes_cycle_user ON votes(cycle_id, user_id);
      CREATE INDEX idx_votes_cycle_book ON votes(cycle_id, book_id);
